import{m as C,q as E,s as z,u as G,x as B,y as F,z as T,C as x,A as I,B as D,D as q,E as R,_ as K,o as S,c as w,a as l,f as W,G as L,t as M,F as N,h as U,H,I as J,J as Q,k as X,p as Y,i as Z}from"./index.9581bafe.js";const _={data:{type:Object,required:!0},options:{type:Object,default:()=>({})},plugins:{type:Array,default:()=>[]},datasetIdKey:{type:String,default:"label"},updateMode:{type:String,default:void 0}},$={type:{type:String,required:!0},..._},j=q[0]==="2"?(t,e)=>Object.assign(t,{attrs:e}):(t,e)=>Object.assign(t,e);function v(t){return R(t)?I(t):t}function tt(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:t;return R(e)?new Proxy(t,{}):t}function et(t,e){const s=t.options;s&&e&&Object.assign(s,e)}function O(t,e){t.labels=e}function P(t,e,s){const i=[];t.datasets=e.map(a=>{const n=t.datasets.find(o=>o[s]===a[s]);return!n||!a.data||i.includes(n)?{...a}:(i.push(n),Object.assign(n,a),n)})}function st(t,e){const s={labels:[],datasets:[]};return O(s,t.labels),P(s,t.datasets,e),s}const it=C({props:$,setup(t,e){let{expose:s}=e;const i=E(null),a=z(null);s({chart:a});const n=()=>{if(!i.value)return;const{type:r,data:c,options:p,plugins:f,datasetIdKey:b}=t,m=st(c,b),u=tt(m,c);a.value=new x(i.value,{type:r,data:u,options:{...p},plugins:f})},o=()=>{const r=I(a.value);r&&(r.destroy(),a.value=null)},d=r=>{r.update(t.updateMode)};return G(n),B(o),F([()=>t.options,()=>t.data],(r,c)=>{let[p,f]=r,[b,m]=c;const u=I(a.value);if(!u)return;let g=!1;if(p){const h=v(p),y=v(b);h&&h!==y&&(et(u,h),g=!0)}if(f){const h=v(f.labels),y=v(m.labels),k=v(f.datasets),V=v(m.datasets);h!==y&&(O(u.config.data,h),g=!0),k&&k!==V&&(P(u.config.data,k,t.datasetIdKey),g=!0)}g&&d(u)},{deep:!0}),()=>T("canvas",{ref:i})}});function at(t,e){return x.register(e),C({props:_,setup(s,i){let{expose:a}=i;const n=z(null),o=d=>{n.value=d==null?void 0:d.chart};return a({chart:n}),()=>T(it,j({ref:o},{type:t,...s}))}})}const nt=at("bar",D),ot={data(){return{recursiveRunning:!1}},methods:{recursiveInit:function(){this.recursiveGrid=[],this.recursiveStack=[],this.initial=0;for(var t=0;t<this.grid.length;t++)this.possible(t),this.grid[t].value&&(this.recursiveStack.push(t),this.initial++)},recursiveSolve:function(){this.recursiveInit(),this.recursiveStack.push(this.fewestPossible()),this.recursiveInterval=setInterval(()=>{this.recursiveRunning||(this.recursiveRunning=!0,this.recursiveStack.length>this.initial&&this.recursiveStack[this.recursiveStack.length-1]!==null?this.recursiveStep():(clearInterval(this.recursiveInterval),this.recursiveRunning=!1),this.recursiveRunning=!1)},10)},recursiveStep:function(){var t=this.recursiveStack[this.recursiveStack.length-1];if(this.recursiveGrid[t].length===0)this.setRecursiveValue(this.recursiveStack.pop());else{var e=this.recursiveGrid[t].splice(Math.floor(Math.random()*this.recursiveGrid[t].length),1)[0];this.setRecursiveValue(t,e),this.recursiveStack.push(this.fewestPossible())}},recursiveStop:function(){clearInterval(this.recursiveInterval)},possible:function(t){var e=[1,2,3,4,5,6,7,8,9];for(var s of this.grid[t].related)e.indexOf(this.grid[s].value)!==-1&&e.splice(e.indexOf(this.grid[s].value),1);this.recursiveGrid[t]=e},setRecursiveValue:function(t,e=null){this.setValue(t,e),e||this.possible(t);for(var s of this.grid[t].related)this.recursiveStack.indexOf(s)===-1&&this.possible(s)},fewestPossible:function(){for(var t=10,e=[],s=0;s<this.grid.length;s++)this.recursiveStack.indexOf(s)===-1&&(this.recursiveGrid[s].length<t?(t=this.recursiveGrid[s].length,e=[s]):this.recursiveGrid[s].length===t&&e.push(s));return e.length===0?null:e[Math.floor(Math.random()*e.length)]}}},rt={data(){return{mcRunning:!1,mcFitness:null,mcTemp:null,mcTotalSteps:null}},methods:{mcInit:function(){this.mcInitial=[],this.mcEmpty=[],this.mcTempTracker=[],this.mcFitnessTracker=[];for(var t=0;t<this.grid.length;t++){if(t%9===0){var e=Math.floor(t/9),s=[1,2,3,4,5,6,7,8,9];this.mcEmpty[e]=[]}if(this.grid[t].value?(s.splice(s.indexOf(this.grid[t].value),1),this.mcInitial.push(t)):this.mcEmpty[e].push(t),t%9===8)for(var i=0;i<this.mcEmpty[e].length;i++)this.setValue(this.mcEmpty[e][i],s[i])}this.mcTotalSteps=0,this.mcTemp=.5,this.mcFitness=this.mcTotalCost()},mcSolve:function(){this.mcInit(),this.mcInterval=setInterval(()=>{if(!this.mcRunning){this.mcRunning=!0;var t=this.mcFitness;this.mcFitnessTracker.push([this.mcTotalSteps,this.mcFitness]),this.mcTempTracker.push([this.mcTotalSteps,this.mcTemp]);for(var e=0;e!==500;)if(e++,this.mcTotalSteps++,this.mcStep(),this.mcFitness===0){clearInterval(this.mcInterval),this.mcRunning=!1,this.mcFitnessTracker.push([this.mcTotalSteps,this.mcFitness]),this.mcTempTracker.push([this.mcTotalSteps,this.mcTemp]),this.mcChart();break}var s=Math.abs(t-this.mcFitness)<1?1.002:.999;this.mcTemp=this.mcTemp*s,this.mcRunning=!1}},100)},mcStep:function(){var t=Math.floor(Math.random()*9),e=this.mcEmpty[t][Math.floor(Math.random()*this.mcEmpty[t].length)],s=this.mcEmpty[t][Math.floor(Math.random()*this.mcEmpty[t].length)],i=this.grid[e].value,a=this.grid[s].value;if(i!==a){var n=this.mcIndividualCost(e)+this.mcIndividualCost(s);this.setValue(e,a),this.setValue(s,i);var o=this.mcIndividualCost(e)+this.mcIndividualCost(s);Math.exp((n-o)/this.mcTemp)>Math.random()?this.mcFitness+=o-n:(this.setValue(e,i),this.setValue(s,a))}},mcStop:function(){clearInterval(this.mcInterval),this.mcChart()},mcChart:function(){this.chartOptions={title:{text:"MonteCarlo"},chart:{type:"line"},rangeSelector:{buttons:[{count:2e4,type:"millisecond",text:"20K"},{count:6e4,type:"millisecond",text:"60K"},{type:"all",text:"All"}],inputEnabled:!1,selection:0},series:[{title:"Fitness",data:this.mcFitnessTracker},{title:"Temperature",data:this.mcTempTracker}],xAxis:{type:"linear"}}},mcTotalCost:function(){var t=0,e=[0,12,24,28,40,52,56,68,80];for(var s of e)t+=this.mcIndividualCost(s);return t},mcIndividualCost:function(t){for(var e,s=[],i=[],a=[],n=0;n<9;n++){var o=Math.floor(t/9)*9+n;s.indexOf(this.grid[o].value)===-1&&s.push(this.grid[o].value);var d=t%9+9*n;i.indexOf(this.grid[d].value)===-1&&i.push(this.grid[d].value);var r=Math.floor(t/27)*27+Math.floor(t%9/3)*3+Math.floor(n/3)*9+n%3;a.indexOf(this.grid[r].value)===-1&&a.push(this.grid[r].value)}return e=27-s.length-i.length-a.length,e}}},lt={methods:{calculateDependencies:function(t){for(var e=[],s=[],i=[],a=Math.floor(t/9)*9,n=t%9,o=Math.floor(t/27)*27+Math.floor(t%9/3)*3,d=0;d<9;d++)e.push(a+d);for(var r=0;r<9;r++)s.push(n+9*r);for(var c=0;c<9;c++)i.push(o+Math.floor(c/3)*9+c%3);return[e,s,i]},resetGrid:function(){}},created(){}};const dt={name:"sudoku",mixins:[rt,ot,lt],components:[nt],data(){return{current:null,grid:[],chartOptions:null,customPuzzle:" 1  2 3    2  3 4  5      6  47   5    1    3 7  68   3    4 9    6  1 4  6      "}},created(){for(var t=0;t<81;t++){for(var e=[],s,i=0;i<9;i++)s=Math.floor(t/9)*9+i,s!==t&&e.indexOf(s)===-1&&e.push(s),s=t%9+9*i,s!==t&&e.indexOf(s)===-1&&e.push(s),s=Math.floor(t/27)*27+Math.floor(t%9/3)*3+Math.floor(i/3)*9+i%3,s!==t&&e.indexOf(s)===-1&&e.push(s);this.grid.push({value:null,related:e,conflicts:[],locked:!1})}},methods:{stop:function(){this.current==="Recursion"&&this.recursiveStop(),this.current==="Monte"&&this.mcStop(),this.current=null},start:function(t){this.lockGrid(),t==="Recursion"?(this.recursiveSolve(),this.current=t):t==="Monte"&&(this.mcSolve(),this.current=t)},load:function(){var t=this.customPuzzle;this.grid.forEach((e,s)=>{e.value=parseInt(t[s])>0&&parseInt(t[s])<10?parseInt(t[s]):null})},get:function(){var t="";this.grid.forEach((e,s)=>{var i,a;t+=(a=(i=e.value)==null?void 0:i.toString())!=null?a:" "}),this.customPuzzle=t},userInput:function(t,e){var s=parseInt(e.key);s<=9&&s>=1?this.setValue(t,s):this.setValue(t)},checkValid:function(t){return this.grid[t].conflicts.length>0},lockGrid:function(){this.grid.forEach(t=>{t.locked=t.value!=null})},unlockGrid:function(){this.grid.forEach(t=>{t.locked=!1})},setValue:function(t,e=null){this.grid[t].value=e;for(var s of this.grid[t].related)this.grid[s].value!==null&&(this.grid[t].value!==null&&this.grid[t].value===this.grid[s].value?this.grid[t].conflicts.indexOf(s)===-1&&(this.grid[t].conflicts.push(s),this.grid[s].conflicts.push(t)):this.grid[t].conflicts.indexOf(s)!==-1&&(this.grid[t].conflicts.splice(this.grid[t].conflicts.indexOf(s),1),this.grid[s].conflicts.splice(this.grid[s].conflicts.indexOf(t),1)))}},computed:{state:function(){for(var t="",e=0;e<this.grid.length;e++)t+=this.grid[e].value?this.grid[e].value:" ";return t}},watch:{},mounted(){},beforeDestroy(){}},A=t=>(Y("data-v-382d8954"),t=t(),Z(),t),ct={class:"f-col f-center main",id:"sudoku"},ut={class:"controls f-row f-center pT-xl f-col-gap-xl"},ht={class:"f-col f-center pH-xl"},vt=A(()=>l("div",{class:"f-center"},"Solve With",-1)),ft={class:"f-row f-center"},pt={class:"f-col f-center pH-xl"},mt=A(()=>l("div",null,"Manage Puzzle",-1)),gt={class:"f-row"},bt={class:"display f-row f-center f-grow pB-xl"},yt={class:"grid f-row"},kt=["value","onKeyup","onKeypress"],St=X('<div class="article f-row pT-xxl pB-xl" data-v-382d8954><span class="f-grow" data-v-382d8954></span><div class="article-content" data-v-382d8954><div class="section-timestamp" data-v-382d8954>2019-03-15</div><div class="article-title pB-l" data-v-382d8954>Mastering Sudoku with Recursion, Monte Carlo, and Simulated Annealing Methods</div><br data-v-382d8954><div class="section-header" data-v-382d8954>Introduction</div><br data-v-382d8954><div class="section-body" data-v-382d8954>Welcome to my Sudoku-solving adventure! Sudoku puzzles have captured the hearts and minds of puzzle enthusiasts around the world. In this blog post, we&#39;ll explore two powerful methods (of varying efficiencies) for solving Sudoku puzzles: Recursion and Monte Carlo. Whether you&#39;re a Sudoku novice or a seasoned pro, these techniques will surely elevate your solving skills.</div><br data-v-382d8954><br data-v-382d8954><div class="section-header" data-v-382d8954>I. Understanding Sudoku</div><br data-v-382d8954><div class="section-body" data-v-382d8954>A crucial aspect of this page was crafting a visually appealing interface. I opted for a simple background image of nature and a slow paced breathing effect, focusing on readability and gentle animations. The shower thoughts were randomly presented across the viewable screen, each with a varying font size to drive home the random nature of shower thoughts. To create a calming ambiance, I incorporated a subtle breathing effect\u2014a gentle fade-in and fade-out for each thought, reminiscent of a peaceful meditation exercise. This effect was achieved using CSS animations, providing visitors with a soothing visual experience.</div><br data-v-382d8954><br data-v-382d8954><div class="section-header" data-v-382d8954>II. The Recursion Approach</div><br data-v-382d8954><div class="section-header" data-v-382d8954>A. What is Recursion?</div><div class="section-body" data-v-382d8954>Recursion involves solving a problem by breaking it down into smaller instances of the same problem. In the context of Sudoku, recursion allows us to tackle the puzzle square by square, simplifying the complex task into more manageable sub-problems.</div><br data-v-382d8954><div class="section-header" data-v-382d8954>B. Applying Recursion to Sudoku</div><div class="section-body" data-v-382d8954>Begin with an empty grid and choose a square. Assume a digit and recursively apply the same process until a solution is found or an incorrect assumption is identified. Backtrack and explore alternative paths until the entire puzzle is solved.</div><br data-v-382d8954><div class="section-header" data-v-382d8954>C. Pros and Cons of Recursion</div><div class="section-body" data-v-382d8954>Pros: Elegant problem decomposition, well-suited for puzzles with logical dependencies.</div><div class="section-body" data-v-382d8954>Cons: May struggle with puzzles requiring extensive trial and error, potentially leading to inefficiencies.</div><br data-v-382d8954><br data-v-382d8954><div class="section-header" data-v-382d8954>III. The Monte Carlo Method</div><br data-v-382d8954><div class="section-header" data-v-382d8954>A. Introduction to Monte Carlo</div><div class="section-body" data-v-382d8954>Monte Carlo is a probabilistic method that leverages randomness to find solutions. In Sudoku, it involves making educated guesses and iteratively refining them based on the puzzle&#39;s constraints.</div><br data-v-382d8954><div class="section-header" data-v-382d8954>B. Applying Monte Carlo to Sudoku</div><div class="section-body" data-v-382d8954>Randomly fill in squares with plausible numbers, considering constraints. Evaluate the puzzle&#39;s validity, and if incorrect, adjust the guessed numbers. Repeat until a solution is found.</div><br data-v-382d8954><div class="section-header" data-v-382d8954>C. Pros and Cons of Monte Carlo</div><div class="section-body" data-v-382d8954>Suitable for puzzles with multiple possible solutions, provides a systematic approach to guessing.</div><div class="section-body" data-v-382d8954>Cons: Relies on randomness, might require more iterations to converge on a solution.</div><br data-v-382d8954><div class="section-header" data-v-382d8954>D. Simulated Annealing Variant</div><div class="section-body" data-v-382d8954>While Monte Carlo by itself can be compared to throwing things at a wall and hoping to get lucky, Simulated Annealing allows for controlled randomization by gradually decreasing the randomness over iterations. This helps in exploring the solution space more effectively, especially when Monte Carlo might get stuck in local optima.</div><br data-v-382d8954><br data-v-382d8954><div class="section-header" data-v-382d8954>IV. Comparing the Methods</div><br data-v-382d8954><div class="section-header" data-v-382d8954>A. Efficiency and Speed</div><div class="section-body" data-v-382d8954>Recursion excels in logically structured puzzles, offering a systematic approach. Monte Carlo, on the other hand, handles puzzles with multiple solutions or complex branching more effectively. The choice depends on the nature of the puzzle.</div><br data-v-382d8954><div class="section-header" data-v-382d8954>B. Implementation Challenges</div><div class="section-body" data-v-382d8954>Recursion might face challenges in puzzles with limited logical deductions, requiring extensive backtracking. Monte Carlo could take longer if the initial guesses are far from the solution. Experimentation is key to finding the most effective approach.</div><br data-v-382d8954><br data-v-382d8954><div class="section-header" data-v-382d8954>V. Conclusion</div><br data-v-382d8954><div class="section-body" data-v-382d8954>In conclusion, both recursion and Monte Carlo methods provide valuable tools for Sudoku enthusiasts. Whether you prefer the systematic approach of recursion or the probabilistic nature of Monte Carlo, mastering both methods opens new dimensions in puzzle-solving. But maybe pick recursion if you&#39;re actually looking to solve your problem in a timely manner.</div><br data-v-382d8954><br data-v-382d8954><div class="section-header" data-v-382d8954>VI. Next Steps</div><br data-v-382d8954><div class="section-header" data-v-382d8954>A. Fine-Tuning Simulated Annealing Parameters</div><div class="section-body" data-v-382d8954>Explore the importance of fine-tuning temperature steps in the Simulated Annealing process. Adjusting temperature schedules can significantly impact the effectiveness of the method in finding optimal solutions.</div><br data-v-382d8954><div class="section-header" data-v-382d8954>B. Genetic Algorithms</div><div class="section-body" data-v-382d8954>Discuss the potential of incorporating Genetic Algorithms into Sudoku solving. Genetic Algorithms involve evolving a population of solutions through crossover and mutation, mimicking natural selection processes.</div></div><span class="f-grow" data-v-382d8954></span></div>',1);function wt(t,e,s,i,a,n){return S(),w("div",null,[l("div",ct,[l("div",ut,[l("div",ht,[vt,l("div",ft,[l("button",{onClick:e[0]||(e[0]=o=>n.start("Recursion"))},"Recursion"),l("button",{onClick:e[1]||(e[1]=o=>n.start("Monte"))},"Monte Carlo"),l("button",{onClick:e[2]||(e[2]=o=>n.stop())},"Stop")])]),l("div",pt,[mt,l("div",gt,[l("button",{onClick:e[3]||(e[3]=o=>n.get())},"Get State"),l("button",{onClick:e[4]||(e[4]=o=>n.load())},"Load Puzzle"),W(l("input",{type:"text","onUpdate:modelValue":e[5]||(e[5]=o=>a.customPuzzle=o)},null,512),[[L,a.customPuzzle]])])]),l("div",null,M(a.current)+" "+M(t.mcFitness)+" "+M(t.mcTemp),1)]),l("div",bt,[l("table",yt,[(S(!0),w(N,null,U(a.grid,(o,d)=>(S(),w("td",{class:"grid-block",key:d},[l("input",{class:H([{locked:o.locked,error:o.conflicts.length>0},"normal"]),value:o.value,onKeyup:J(r=>n.userInput(d,r),["delete"]),onKeypress:Q(r=>n.userInput(d,r),["prevent"])},null,42,kt)]))),128))])])]),St])}const It=K(dt,[["render",wt],["__scopeId","data-v-382d8954"]]);export{It as default};
